\ $Id: lisp.frt,v 1.2 2018/01/28 19:34:07 albert Exp $
\ Copyright (C) 1999 Mark Probst
\ Ansification (2018): Albert van der Horst
\ Copyright by GPL: quality by no warranty.
\ See the obligatory blurb at the end.

\ A Lisp interpreter in Forth

\ Port for Camel99 Forth by Brian Fox
\ Camel99 Harness
INCLUDE DSK1.TOOLS
INCLUDE DSK1.VALUES
INCLUDE DSK1.ALLOCATE
INCLUDE DSK1.COMPARE
INCLUDE DSK1.ANSFILES

: THROW  ABORT" Error thrown" ;

\ helper to reduce size
: BETWEEN   1+  WTIHIN ;

INCLUDE DSK1.EMPTY
EMPTY

HERE
\ Copyright (2018): Albert van der Horst {by GNU Public License}
\ structs with active fields, in fact objects.

VARIABLE OFFSET

: STRUCT   0 OFFSET ! ;

\ Create field  "name"  with  offset  size  . Leave new  offset  .
\ name execution: turn  struct   into a  field
: FIELD   :  OFFSET @ POSTPONE LITERAL POSTPONE +
   POSTPONE ;  OFFSET +! ;

: END-STRUCT  OFFSET @ CONSTANT ;  \ leaves size of struct
: ENDIF POSTPONE THEN ; IMMEDIATE

1 CELLS CONSTANT CELL


0 VALUE U
0 VALUE A
: STRING-NEW  TO U  TO A
    A U ALLOCATE DROP DUP >R U CMOVE
    R> U ;

: STRING>NUM ( A U -- N )
    0 SWAP 0 ?DO
        10 * OVER I + C@ [CHAR] 0 - +
    LOOP
    NIP ;

\ All recursive and mutually recursive words are handled by DEFER.
\ A word starting with _ is probably recursive
DEFER LISP-READ-LISP
DEFER LISP-SPECIAL-COND
DEFER LISP-READ-LIST
DEFER LISP-EVAL-LIST

\ symbol table

STRUCT
    2 CELLS FIELD SYMTAB-NAME
    CELL FIELD SYMTAB-LISP
    CELL FIELD SYMTAB-NEXT
END-STRUCT SYMTAB

VARIABLE SYMTAB-FIRST

: SYMTAB-LOOKUP
    SYMTAB-FIRST @
    BEGIN
        DUP
    WHILE
        >R
        2DUP R@ SYMTAB-NAME 2@ COMPARE
        0= IF
           2DROP R> SYMTAB-LISP @ EXIT
        ENDIF
        R> SYMTAB-NEXT @
    REPEAT
    DROP 2DROP 0 ;

0 VALUE LISP
0 VALUE NAMEU
0 VALUE NAMEA

: SYMTAB-ADD  TO LISP  TO NAMEU  TO NAMEA
    SYMTAB ALLOCATE THROW
    DUP >R NAMEA NAMEU R> SYMTAB-NAME 2!
    DUP SYMTAB-LISP LISP SWAP !
    DUP SYMTAB-NEXT SYMTAB-FIRST @ SWAP !
    SYMTAB-FIRST ! ;

: SYMTAB-SAVE ( -- PTR )
    SYMTAB-FIRST @ ;

: SYMTAB-RESTORE ( PTR -- )
    SYMTAB-FIRST ! ;

\ lisp interpreter

0 CONSTANT LISP-PAIR-TAG
1 CONSTANT LISP-NUMBER-TAG
2 CONSTANT LISP-BUILTIN-TAG
3 CONSTANT LISP-SYMBOL-TAG
4 CONSTANT LISP-SPECIAL-TAG
5 CONSTANT LISP-COMPOUND-TAG
6 CONSTANT LISP-MAX-TAG

LISP-MAX-TAG CELLS ALLOCATE THROW CONSTANT EVAL-DISPATCH
LISP-MAX-TAG CELLS ALLOCATE THROW CONSTANT DISPLAY-DISPATCH
LISP-MAX-TAG CELLS ALLOCATE THROW CONSTANT EQ?-DISPATCH

STRUCT
    CELL FIELD LISP-TAG
END-STRUCT LISP

STRUCT
    CELL FIELD PAIR-TAG
    CELL FIELD PAIR-CAR
    CELL FIELD PAIR-CDR
END-STRUCT LISP-PAIR

STRUCT
    CELL FIELD NUMBER-TAG
    CELL FIELD NUMBER-NUM
END-STRUCT LISP-NUMBER

STRUCT
    CELL FIELD BUILTIN-TAG
    CELL FIELD BUILTIN-XT
END-STRUCT LISP-BUILTIN

STRUCT
    CELL FIELD SYMBOL-TAG
    2 CELLS FIELD SYMBOL-NAME
END-STRUCT LISP-SYMBOL

STRUCT
    CELL FIELD SPECIAL-TAG
    CELL FIELD SPECIAL-XT
END-STRUCT LISP-SPECIAL

STRUCT
    CELL FIELD COMPOUND-TAG
    CELL FIELD COMPOUND-ARGS
    CELL FIELD COMPOUND-BODY
END-STRUCT LISP-COMPOUND

0 VALUE CDR
0 VALUE CAR

: CONS  TO CDR  TO CAR
    LISP-PAIR ALLOCATE THROW
    DUP PAIR-TAG LISP-PAIR-TAG SWAP !
    DUP PAIR-CAR CAR SWAP !
    DUP PAIR-CDR CDR SWAP ! ;

: CAR ( PAIR -- LISP )
    PAIR-CAR @ ;

: CDR ( PAIR -- LISP )
    PAIR-CDR @ ;

0 VALUE NUM
: NUMBER  TO NUM
    LISP-NUMBER ALLOCATE THROW
    DUP NUMBER-TAG LISP-NUMBER-TAG SWAP !
    DUP NUMBER-NUM NUM SWAP ! ;

0 VALUE XT
: BUILTIN  TO XT
    LISP-BUILTIN ALLOCATE THROW
    DUP BUILTIN-TAG LISP-BUILTIN-TAG SWAP !
    DUP BUILTIN-XT XT SWAP ! ;

0 VALUE NAMEU
0 VALUE NAMEA
: SYMBOL  TO NAMEU  TO NAMEA
    LISP-SYMBOL ALLOCATE THROW
    DUP SYMBOL-TAG LISP-SYMBOL-TAG SWAP !
    DUP >R NAMEA NAMEU R> SYMBOL-NAME 2! ;

: SYMBOL-NEW ( NAMEA NAMEU -- LISP )
    STRING-NEW SYMBOL ;

0 VALUE XT
: SPECIAL  TO XT
    LISP-SPECIAL ALLOCATE THROW
    DUP SPECIAL-TAG LISP-SPECIAL-TAG SWAP !
    DUP SPECIAL-XT XT SWAP ! ;

0 VALUE BODY
0 VALUE ARGS
: COMPOUND  TO BODY  TO ARGS
    LISP-COMPOUND ALLOCATE THROW
    DUP COMPOUND-TAG LISP-COMPOUND-TAG SWAP !
    DUP COMPOUND-ARGS ARGS SWAP !
    DUP COMPOUND-BODY BODY SWAP ! ;

: LISP-DISPLAY ( LISP -- )
    DUP 0= IF  DROP  ." ()"  EXIT  ENDIF
    DUP LISP-TAG @ CELLS DISPLAY-DISPATCH + @ EXECUTE ;

: LISP-DISPLAY-PAIR ( LISP -- )
    [CHAR] ( EMIT SPACE
    BEGIN
        DUP CAR LISP-DISPLAY SPACE
        CDR
        DUP 0=
    UNTIL
    DROP
    [CHAR] ) EMIT ;

' LISP-DISPLAY-PAIR DISPLAY-DISPATCH LISP-PAIR-TAG CELLS + !

: LISP-DISPLAY-NUMBER ( LISP -- )
    NUMBER-NUM @ . ;

' LISP-DISPLAY-NUMBER DISPLAY-DISPATCH LISP-NUMBER-TAG CELLS + !

: LISP-DISPLAY-BUILTIN ( LISP -- )
    [CHAR] $ EMIT SPECIAL-XT @ . ;

' LISP-DISPLAY-BUILTIN DISPLAY-DISPATCH LISP-BUILTIN-TAG CELLS + !

0 VALUE LISP
: LISP-DISPLAY-SYMBOL  TO LISP
    LISP SYMBOL-NAME 2@ TYPE ;

' LISP-DISPLAY-SYMBOL DISPLAY-DISPATCH LISP-SYMBOL-TAG CELLS + !

: LISP-DISPLAY-SPECIAL ( LISP -- )
    [CHAR] # EMIT SPECIAL-XT @ . ;

' LISP-DISPLAY-SPECIAL DISPLAY-DISPATCH LISP-SPECIAL-TAG CELLS + !

: LISP-DISPLAY-COMPOUND ( LISP -- )
    [CHAR] & EMIT COMPOUND-BODY @ . ;

' LISP-DISPLAY-COMPOUND DISPLAY-DISPATCH LISP-COMPOUND-TAG CELLS + !

: LISP-EVAL ( LISP -- LISP )
    DUP  IF
        DUP LISP-TAG @ CELLS EVAL-DISPATCH + @ EXECUTE
    ENDIF ;

: _LISP-EVAL-LIST ( LISP -- LISP )
    DUP  IF
        DUP CAR LISP-EVAL SWAP CDR LISP-EVAL-LIST CONS
    ENDIF ;
' _LISP-EVAL-LIST IS LISP-EVAL-LIST

: LISP-BIND-VAR ( NAME VALUE -- )
    >R SYMBOL-NAME 2@  R> SYMTAB-ADD ;

: LISP-BIND-VARS ( NAMES VALUES -- )
    SWAP
    BEGIN
        DUP
    WHILE
        2DUP CAR SWAP CAR LISP-BIND-VAR
        CDR SWAP CDR SWAP
    REPEAT
    2DROP ;

: LISP-APPLY-COMPOUND ( FUNC ARGS -- LISP )
    SYMTAB-SAVE >R
    OVER COMPOUND-ARGS @ SWAP LISP-BIND-VARS
    COMPOUND-BODY @ LISP-EVAL
    R> SYMTAB-RESTORE ;

: LISP-APPLY ( FUNC ARGS -- LISP )
    >R DUP LISP-TAG @ LISP-BUILTIN-TAG = IF
        R> SWAP BUILTIN-XT @ EXECUTE
    ELSE
        R> LISP-APPLY-COMPOUND
    ENDIF ;

: LISP-EVAL-PAIR ( LISP -- LISP )
    >R
    R@ CAR LISP-EVAL
    DUP LISP-TAG @ LISP-SPECIAL-TAG = IF
        R> CDR SWAP SPECIAL-XT @ EXECUTE
    ELSE
        R> CDR LISP-EVAL-LIST LISP-APPLY
    ENDIF ;

' LISP-EVAL-PAIR EVAL-DISPATCH LISP-PAIR-TAG CELLS + !

: LISP-EVAL-NUMBER ( LISP -- LISP ) ;

' LISP-EVAL-NUMBER EVAL-DISPATCH LISP-NUMBER-TAG CELLS + !

: LISP-EVAL-BUILTIN ( LISP -- LISP ) ;

' LISP-EVAL-BUILTIN EVAL-DISPATCH LISP-BUILTIN-TAG CELLS + !

0 VALUE LISP
: LISP-EVAL-SYMBOL  TO LISP
    LISP SYMBOL-NAME 2@ SYMTAB-LOOKUP ;

' LISP-EVAL-SYMBOL EVAL-DISPATCH LISP-SYMBOL-TAG CELLS + !

: LISP-EVAL-SPECIAL ( LISP -- LISP ) ;

' LISP-EVAL-SPECIAL EVAL-DISPATCH LISP-SPECIAL-TAG CELLS + !

: LISP-EVAL-COMPOUND ( LISP -- LISP ) ;

' LISP-EVAL-COMPOUND EVAL-DISPATCH LISP-COMPOUND-TAG CELLS + !

\ THE READER
: <=  1+ < ;
: LISP-READ-CHAR ( E A -- E A C )
    2DUP <= IF
        0
    ELSE
        DUP C@
        SWAP 1+ SWAP
    ENDIF ;

: LISP-UNREAD-CHAR ( E A -- E A )
    1- ;

: LISP-IS-WS ( C -- FLAG )
    DUP 10 = SWAP
    DUP 13 = SWAP
    DUP  9 = SWAP
    BL = OR OR OR ;

: LISP-SKIP-WS ( E A -- E A )
    LISP-READ-CHAR
    BEGIN
        DUP  OVER LISP-IS-WS AND
    WHILE
        DROP LISP-READ-CHAR
    REPEAT
    IF
        LISP-UNREAD-CHAR
    ENDIF ;

128 ALLOCATE THROW CONSTANT TOKEN-BUFFER

: LISP-READ-TOKEN ( E A -- E A A U )
    LISP-SKIP-WS
    0 >R
    LISP-READ-CHAR
    BEGIN
        DUP [CHAR] ) <> OVER 0 <> AND OVER LISP-IS-WS 0= AND
    WHILE
        TOKEN-BUFFER R@ + C! R> 1+ >R LISP-READ-CHAR
    REPEAT
     IF
        LISP-UNREAD-CHAR
    ENDIF
    TOKEN-BUFFER R> ;


: _LISP-READ-LIST ( E A -- E A LISP )
    LISP-SKIP-WS LISP-READ-CHAR
    DUP [CHAR] ) = SWAP 0 = OR IF  0   EXIT ENDIF

    LISP-UNREAD-CHAR LISP-READ-LISP >R LISP-READ-LIST R> SWAP CONS
;
' _LISP-READ-LIST IS LISP-READ-LIST

: LISP-READ-NUMBER ( E A -- E A LISP )
    LISP-READ-TOKEN STRING>NUM NUMBER ;

: LISP-READ-SYMBOL ( E A -- E A LISP )
    LISP-READ-TOKEN STRING-NEW SYMBOL ;

: >=  1- > ;

: _LISP-READ-LISP ( E A -- E A LISP )
    LISP-SKIP-WS LISP-READ-CHAR
    DUP 0= IF
        DROP 0
    ELSE
        DUP [CHAR] ( = IF
            DROP LISP-READ-LIST
        ELSE
            DUP [CHAR] 0 >= SWAP [CHAR] 9 <= AND IF
                LISP-UNREAD-CHAR LISP-READ-NUMBER
            ELSE
                LISP-UNREAD-CHAR LISP-READ-SYMBOL
            ENDIF
        ENDIF
    ENDIF ;
' _LISP-READ-LISP IS LISP-READ-LISP

: LISP-LOAD-FROM-STRING ( A U -- LISP )
    OVER + SWAP
    0 >R
    BEGIN
        LISP-SKIP-WS 2DUP >
    WHILE
        R> DROP LISP-READ-LISP LISP-EVAL >R
    REPEAT
    2DROP R> ;

128 ALLOCATE THROW CONSTANT READ-BUFFER

\ TI-99 has record based file system so this had to be changed
: LISP-LOAD-FROM-FILE ( A U -- LISP )
    DV80 R/O OPEN-FILE ?FILERR >R
    BEGIN
        READ-BUFFER DUP 80 R@ READ-LINE NIP ( $ len ior)
    0= WHILE
        LISP-LOAD-FROM-STRING
    REPEAT
    R> CLOSE-FILE DROP
;

\ SPECIALS

: LISP-SPECIAL-QUOTE ( LISP -- LISP )
    CAR ;

S" QUOTE" STRING-NEW ' LISP-SPECIAL-QUOTE SPECIAL SYMTAB-ADD

: LISP-SPECIAL-LAMBDA ( LISP -- LISP )
    DUP CAR SWAP CDR CAR COMPOUND ;

S" LAMBDA" STRING-NEW ' LISP-SPECIAL-LAMBDA SPECIAL SYMTAB-ADD

: LISP-SPECIAL-DEFINE ( LISP -- LISP )
    DUP CAR SWAP CDR CAR LISP-EVAL LISP-BIND-VAR 0 ;

S" DEFINE" STRING-NEW ' LISP-SPECIAL-DEFINE SPECIAL SYMTAB-ADD

0 CONSTANT LISP-FALSE
0 0 CONS CONSTANT LISP-TRUE

S" T" STRING-NEW LISP-TRUE SYMTAB-ADD

: _LISP-SPECIAL-COND ( LISP -- LISP )
    DUP CAR CAR LISP-EVAL  IF
        CAR CDR CAR LISP-EVAL
    ELSE
        CDR DUP  IF
            LISP-SPECIAL-COND
        ENDIF
    ENDIF ;
' _LISP-SPECIAL-COND  IS LISP-SPECIAL-COND

S" COND" STRING-NEW ' LISP-SPECIAL-COND SPECIAL SYMTAB-ADD

\ BUILTINS

: LISP-BUILTIN-+ ( LISP -- LISP )
    0 SWAP
    BEGIN
        DUP
    WHILE
        DUP CAR NUMBER-NUM @ ROT + SWAP CDR
    REPEAT
    DROP NUMBER ;

S" +" STRING-NEW ' LISP-BUILTIN-+ BUILTIN SYMTAB-ADD

: LISP-BUILTIN-- ( LISP -- LISP )
    DUP CAR NUMBER-NUM @ SWAP CDR DUP 0= IF
        DROP NEGATE NUMBER
    ELSE
        SWAP
        BEGIN
            OVER CAR NUMBER-NUM @ - SWAP CDR SWAP
            OVER 0=
        UNTIL
        NIP NUMBER
    ENDIF ;

S" -" STRING-NEW ' LISP-BUILTIN-- BUILTIN SYMTAB-ADD

: LISP-BUILTIN-* ( LISP -- LISP )
    1 SWAP
    BEGIN
        DUP
    WHILE
        DUP CAR NUMBER-NUM @ ROT * SWAP CDR
    REPEAT
    DROP NUMBER ;

S" *" STRING-NEW ' LISP-BUILTIN-* BUILTIN SYMTAB-ADD

: LISP-BUILTIN-CONS ( LISP -- LISP )
    DUP CAR SWAP CDR CAR CONS ;

S" CONS" STRING-NEW ' LISP-BUILTIN-CONS BUILTIN SYMTAB-ADD

: LISP-BUILTIN-CAR ( LISP -- LISP )
    CAR CAR ;

S" CAR" STRING-NEW ' LISP-BUILTIN-CAR BUILTIN SYMTAB-ADD

: LISP-BUILTIN-CDR ( LISP -- LISP )
    CAR CDR ;

S" CDR" STRING-NEW ' LISP-BUILTIN-CDR BUILTIN SYMTAB-ADD

: LISP-BUILTIN-EQ? ( LISP -- LISP )
    DUP CAR SWAP CDR CAR 2DUP = IF
        2DROP LISP-TRUE
    ELSE
        2DUP LISP-TAG @ SWAP LISP-TAG @ <> IF
            2DROP LISP-FALSE
        ELSE
            DUP LISP-TAG @ CELLS EQ?-DISPATCH + @ EXECUTE
        ENDIF
    ENDIF ;

S" EQ?" STRING-NEW ' LISP-BUILTIN-EQ? BUILTIN SYMTAB-ADD

' LISP-FALSE EQ?-DISPATCH LISP-PAIR-TAG CELLS + !

: LISP-EQ?-NUMBER ( LISP LISP -- LISP )
    NUMBER-NUM @ SWAP NUMBER-NUM @ = IF
        LISP-TRUE
    ELSE
        LISP-FALSE
    ENDIF ;

' LISP-EQ?-NUMBER EQ?-DISPATCH LISP-NUMBER-TAG CELLS + !

' LISP-FALSE EQ?-DISPATCH LISP-BUILTIN-TAG CELLS + !

0 VALUE LISP2
0 VALUE LISP1
: LISP-EQ?-SYMBOL  TO LISP2  TO LISP1
    LISP1 SYMBOL-NAME 2@  LISP2 SYMBOL-NAME 2@
    COMPARE 0= IF
        LISP-TRUE
    ELSE
        LISP-FALSE
    ENDIF ;

' LISP-EQ?-SYMBOL EQ?-DISPATCH LISP-SYMBOL-TAG CELLS + !

' LISP-FALSE EQ?-DISPATCH LISP-COMPOUND-TAG CELLS + !

: LISP-BUILTIN-DISPLAY ( LISP -- LISP )
    CAR LISP-DISPLAY 0 ;

S" DISPLAY" STRING-NEW ' LISP-BUILTIN-DISPLAY BUILTIN SYMTAB-ADD

HERE SWAP - DECIMAL . .( bytes)


\ Obligatory GPL blurb:
\ This program is free software; you can redistribute it and/or
\ modify it under the terms of the GNU General Public License
\ as published by the Free Software Foundation; either version 2
\ of the License, or (at your option) any later version.
\
\ This program is distributed in the hope that it will be useful,
\ but WITHOUT ANY WARRANTY; without even the implied warranty of
\ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
\ GNU General Public License for more details.
\
\ You should have received a copy of the GNU General Public License
\ along with this program; if not, write to the Free Software
\ Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
